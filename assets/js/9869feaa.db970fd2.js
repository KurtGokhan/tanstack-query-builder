"use strict";(self.webpackChunktanstack_query_builder_website=self.webpackChunktanstack_query_builder_website||[]).push([[862],{3023:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(3696);const a={},s=i.createContext(a);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:t},e.children)}},6846:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api/tags","title":"Tags API","description":"The Tags API provides imperative methods invalidate or update tags in the cache.","source":"@site/docs/api/tags.mdx","sourceDirName":"api","slug":"/api/tags","permalink":"/tanstack-query-builder/api/tags","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"title":"Tags API","sidebar_position":20},"sidebar":"tutorialSidebar","previous":{"title":"Client API","permalink":"/tanstack-query-builder/api/client"},"next":{"title":"Complete Example","permalink":"/tanstack-query-builder/examples/main"}}');var a=n(2540),s=n(3023);const o={title:"Tags API",sidebar_position:20},r=void 0,d={},c=[{value:"Methods",id:"methods",level:2},{value:"useOperation",id:"useoperation",level:3},{value:"operate",id:"operate",level:3},{value:"update",id:"update",level:3},{value:"Types",id:"types",level:2},{value:"TagOperationOptions",id:"tagoperationoptions",level:3},{value:"TagList",id:"taglist",level:3}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["The Tags API provides imperative methods invalidate or update tags in the cache.\nIt can be accessed via ",(0,a.jsx)(t.a,{href:"./builder#tags",children:(0,a.jsx)(t.code,{children:"builder.tags"})})," in the ",(0,a.jsx)(t.code,{children:"QueryBuilder"})," instance."]}),"\n",(0,a.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(t.h3,{id:"useoperation",children:"useOperation"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"useOperation(options: TagOperationOptions): [operate, MutationResult]\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is a hook that returns a function to operate on the tags, and the result of the operation.\nThis function uses the ",(0,a.jsx)(t.code,{children:"useMutation"})," hook under the hood, so it can be used in a similar way.\nFor example the ",(0,a.jsx)(t.code,{children:"operate"})," function can be awaited, or ",(0,a.jsx)(t.code,{children:"isPending"})," of the result be used to check if the operation is pending."]}),"\n",(0,a.jsx)(t.h3,{id:"operate",children:"operate"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"operate(options: TagOperationOptions): Promise<void>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This function behaves like the ",(0,a.jsx)(t.code,{children:"useOperation"})," hook, but can also be used outside of React components."]}),"\n",(0,a.jsxs)(t.p,{children:["There are also shorthands for all of the operations, which are: ",(0,a.jsx)(t.code,{children:"invalidate"}),", ",(0,a.jsx)(t.code,{children:"refetch"}),", ",(0,a.jsx)(t.code,{children:"reset"}),", ",(0,a.jsx)(t.code,{children:"cancel"}),", and ",(0,a.jsx)(t.code,{children:"remove"}),".\nThese shorthands have the same signature as the ",(0,a.jsx)(t.code,{children:"operate"})," function with the ",(0,a.jsx)(t.code,{children:"operation"})," option set to the corresponding operation."]}),"\n",(0,a.jsx)(t.h3,{id:"update",children:"update"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"update(options: TagUpdateOptions): Promise<void>\n"})}),"\n",(0,a.jsx)(t.p,{children:"This function updates the queries that are tagged with the specified tags.\nIt can be used to update the queries in the cache without refetching them.\nYou don't need to use this function for most cases, it can be useful in some advanced scenarios."}),"\n",(0,a.jsx)(t.h2,{id:"types",children:"Types"}),"\n",(0,a.jsx)(t.h3,{id:"tagoperationoptions",children:"TagOperationOptions"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'type TagOperationOptions = {\n  tags?: TagList;\n  operation?: "invalidate" | "refetch" | "reset" | "cancel" | "remove";\n  filters?: InvalidateQueryFilters;\n  options?: InvalidateOptions;\n};\n'})}),"\n",(0,a.jsx)(t.h3,{id:"taglist",children:"TagList"}),"\n",(0,a.jsxs)(t.p,{children:["This type is used to define the tags that will be used in operations like invalidate or update.\nIt can be a single tag, an array of tags, or a function that returns a tag list. Each tag can be a string, an object with a ",(0,a.jsx)(t.code,{children:"type"})," and ",(0,a.jsx)(t.code,{children:"id"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Some examples:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'// When defining tags:\nbuilder.withTags("articles");\nbuilder.withTags(({ data }) => ({ type: "article", id: data.id }));\nbuilder.withTags("articles", "entities");\n\n// Usage in Tags APIs:\nbuilder.tags.invalidate({ tags: "articles" });\nbuilder.tags.invalidate({ tags: { type: "article", id: 1 } });\nbuilder.tags.invalidate({ tags: ["articles", { type: "article", id: 1 }] });\n\n// When updating tags:\nbuilder.withUpdates(({ vars }) => ({\n  type: "article",\n  id: vars.params.id,\n  optimistic: true,\n  updater: () => {\n    /* update logic */\n  },\n}));\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);